{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/plan.worker.js","webpack:///./src/vec.ts","webpack:///./src/optimization.ts","webpack:///./src/paper-size.ts","webpack:///./src/planning.ts","webpack:///./src/util.ts","webpack:///./src/massager.ts","webpack:///./src/background-planner.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","vlen2","a","x","y","vlen","Math","sqrt","vsub","b","vmul","vnorm","vadd","dropWhile","f","slice","findIndex","joinNearby","pointLists","tolerance","tol2","reduce","length","concat","v","maybeJoin","elideShortPaths","minimumPathLength","filter","pl","pointList","lastPoint","pathLength","vround","digits","Number","toFixed","PaperSize","size","this","max","min","standard","ArchA","landscape","Set","Device","Axidraw","stepsPerMm","penServoMin","penServoMax","pct","round","penPctToPos","accel","duration","vInitial","p1","p2","Error","distance","tU","dt","ds","PenMotion","initialPos","finalPos","pDuration","scanLeft","z","op","acc","push","XYMotion","blocks","ts","map","ss","deserialize","idx","array","obj","low","high","mid","floor","sortedIndex","blockIdx","instant","serialize","Plan","motions","penUpHeight","penDownHeight","penMotionIndex","motion","j","maxEntryVelocity","entryVelocity","computeTriangle","initialVel","finalVel","p3","acceleratingDistance","deceleratingDistance","vMax","s1","s2","t1","t2","computeTrapezoid","maxVel","p4","t3","s3","dir","constantAccelerationPlan","points","profile","dedupedPoints","epsilon","dedupPoints","segments","acceleration","maximumVelocity","cornerFactor","corneringFactor","forEach","seg2","seg1","cosine","direction","abs","sine","cornerVelocity","segment","nextSegment","vExit","vFinal","scaleToPaper","paperSize","marginMm","targetMin","targetMax","maxX","Infinity","maxY","minX","minY","extent","availWidthMm","availHeightMm","scaleFitX","scaleFitY","scale","targetCenter","offset","scaleToFit","liangBarsky","aabb","seg","lower","upper","delta","q","u1","u2","contains","point","truncate","containsA","containsB","forwards","backwards","cropLineToAabb","truncatedPointLists","currentPointList","truncated","replan","inPaths","planOptions","paths","fitPage","ps","cropToMargins","pageAabb","margin","insetAabb","croppedLine","layerMode","path","selectedGroupLayers","has","groupId","selectedStrokeLayers","stroke","pointJoinRadius","epsilon2","sortPaths","console","time","dist2Between","pa","pb","dx","dy","unvisited","add","sortedPointLists","firstIdx","delete","nextIdx","minD","reverse","timeEnd","pathJoinRadius","plan","curPos","penDownProfile","penUpPos","penUpProfile","penDownPos","penDropDuration","penLiftDuration","penDownAcceleration","penDownMaxVelocity","penDownCorneringFactor","penUpAcceleration","penUpMaxVelocity","self","addEventListener","data","serialized","postMessage"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,G,kBClFrD,EAAQ,I,6BCAD,SAASC,EAAMC,GAClB,OAAOA,EAAEC,EAAID,EAAEC,EAAID,EAAEE,EAAIF,EAAEE,EAExB,SAASC,EAAKH,GACjB,OAAOI,KAAKC,KAAKN,EAAMC,IAEpB,SAASM,EAAKN,EAAGO,GACpB,MAAO,CAAEN,EAAGD,EAAEC,EAAIM,EAAEN,EAAGC,EAAGF,EAAEE,EAAIK,EAAEL,GAE/B,SAASM,EAAKR,EAAGF,GACpB,MAAO,CAAEG,EAAGD,EAAEC,EAAIH,EAAGI,EAAGF,EAAEE,EAAIJ,GAE3B,SAASW,EAAMT,GAClB,OAAOQ,EAAKR,EAAG,EAAIG,EAAKH,IAErB,SAASU,EAAKV,EAAGO,GACpB,MAAO,CAAEN,EAAGD,EAAEC,EAAIM,EAAEN,EAAGC,EAAGF,EAAEE,EAAIK,EAAEL,GCftC,SAASS,EAAUX,EAAGY,GAClB,OAAOZ,EAAEa,MAAMb,EAAEc,UAAWb,IAAOW,EAAEX,KAclC,SAASc,EAAWC,EAAYC,EAAY,IAC/C,MAAMC,EAAOD,EAAYA,EAczB,OAAOD,EAAWG,QALlB,SAAuBnB,EAAGO,GACtB,OAAoB,IAAbP,EAAEoB,OACH,CAACb,GACDP,EAAEa,MAAM,GAAI,GAAGQ,OAXzB,SAAmBrB,EAAGO,GAClB,OAAIR,EAAMO,EAAKN,EAAEA,EAAEoB,OAAS,GAAIb,EAAE,MAAQW,EAC/B,CAAClB,EAAEqB,OAAOV,EAAUJ,EAAIe,GAAMvB,EAAMO,EAAKN,EAAEA,EAAEoB,OAAS,GAAIE,KAAOJ,KAGjE,CAAClB,EAAGO,GAMagB,CAAUvB,EAAEA,EAAEoB,OAAS,GAAIb,MAEnB,IAcrC,SAASiB,EAAgBR,EAAYS,GACxC,OAAOT,EAAWU,OAAQC,GAb9B,SAAoBC,GAChB,GAAIA,EAAUR,QAAU,EACpB,OAAO,EAEX,IAAIA,EAAS,EACTS,EAAYD,EAAU,GAC1B,IAAK,IAAI7D,EAAI,EAAGA,EAAI6D,EAAUR,OAAQrD,IAClCqD,GAAUjB,EAAKG,EAAKuB,EAAWD,EAAU7D,KACzC8D,EAAYD,EAAU7D,GAE1B,OAAOqD,EAG0BU,CAAWH,IAAOF,GC7CvD,SAASM,EAAOT,EAAGU,EAAS,GACxB,MAAO,CAAE/B,EAAGgC,OAAOX,EAAErB,EAAEiC,QAAQF,IAAU9B,EAAG+B,OAAOX,EAAEpB,EAAEgC,QAAQF,K,OAE5D,MAAMG,EACT,YAAYC,GACRC,KAAKD,KAAOA,EAEhB,gBACI,OAAO,IAAID,EAAU,CACjBlC,EAAGG,KAAKkC,IAAID,KAAKD,KAAKnC,EAAGoC,KAAKD,KAAKlC,GACnCA,EAAGE,KAAKmC,IAAIF,KAAKD,KAAKnC,EAAGoC,KAAKD,KAAKlC,KAG3C,eACI,OAAO,IAAIiC,EAAU,CACjBlC,EAAGG,KAAKmC,IAAIF,KAAKD,KAAKnC,EAAGoC,KAAKD,KAAKlC,GACnCA,EAAGE,KAAKkC,IAAID,KAAKD,KAAKnC,EAAGoC,KAAKD,KAAKlC,KAG3C,kBACI,OAAOmC,KAAKD,KAAKnC,IAAMG,KAAKkC,IAAID,KAAKD,KAAKnC,EAAGoC,KAAKD,KAAKlC,IAG/DiC,EAAUK,SAAW,CACjB,SAAY,IAAIL,EAAUJ,EAAOvB,EAAK,CAAEP,EAAG,IAAKC,EAAG,IAAM,QACzD,QAAW,IAAIiC,EAAUJ,EAAOvB,EAAK,CAAEP,EAAG,IAAKC,EAAG,IAAM,QACxD,MAAS,IAAIiC,EAAUJ,EAAOvB,EAAK,CAAEP,EAAG,EAAGC,EAAG,IAAM,QACpD,GAAM,IAAIiC,EAAU,CAAElC,EAAG,IAAKC,EAAG,MACjC,GAAM,IAAIiC,EAAU,CAAElC,EAAG,IAAKC,EAAG,MACjC,GAAM,IAAIiC,EAAU,CAAElC,EAAG,IAAKC,EAAG,MACjC,GAAM,IAAIiC,EAAU,CAAElC,EAAG,IAAKC,EAAG,MACjC,MAAO,IAAIiC,EAAUJ,EAAOvB,EAAK,CAAEP,EAAG,EAAGC,EAAG,GAAK,QACjD,MAAO,IAAIiC,EAAUJ,EAAOvB,EAAK,CAAEP,EAAG,EAAGC,EAAG,GAAK,QACjD,QAAS,IAAIiC,EAAUJ,EAAOvB,EAAK,CAAEP,EAAG,GAAIC,EAAG,IAAM,SCvB1CiC,EAAUK,SAASC,MAAMC,UAEf,IAAIC,IACH,IAAIA,IAX9B,MAyBaC,EAAS,CAClBC,QAAS,CACLC,WAAY,EAIZC,YAAa,KACbC,YAAa,KACb,YAAYC,GACR,MAAMhE,EAAIgE,EAAM,IAChB,OAAO7C,KAAK8C,MAAMb,KAAKU,YAAc9D,EAAIoD,KAAKW,aAAe,EAAI/D,OAMjD2D,EAAOC,QAAQC,WACbF,EAAOC,QAAQC,WACZF,EAAOC,QAAQC,WAGpBF,EAAOC,QAAQC,WACZF,EAAOC,QAAQC,WAGhCF,EAAOC,QAAQM,YAAY,IACzBP,EAAOC,QAAQM,YAAY,IAIpC,MAAM,EACT,YAAYC,EAAOC,EAAUC,EAAUC,EAAIC,GACvC,KAAMF,GAAY,GACd,MAAM,IAAIG,MAAM,kCAAkCH,GAEtD,KAAMA,EAAWF,EAAQC,IA5DjB,MA6DJ,MAAM,IAAII,MAAM,qCAAqCH,eAAsBD,YAAmBD,KAElGf,KAAKe,MAAQA,EACbf,KAAKgB,SAAWA,EAChBhB,KAAKiB,SAAWA,EAChBjB,KAAKkB,GAAKA,EACVlB,KAAKmB,GAAKA,EACVnB,KAAKqB,SAAWvD,EAAKG,EAAKiD,EAAIC,IAElC,mBAAmBhF,GACf,OAAO,IAAI,EAAMA,EAAE4E,MAAO5E,EAAE6E,SAAU7E,EAAE8E,SAAU9E,EAAE+E,GAAI/E,EAAEgF,IAE9D,aAAe,OAAOpD,KAAKkC,IAAI,EAAGD,KAAKiB,SAAWjB,KAAKe,MAAQf,KAAKgB,UACpE,QAAQM,EAAIC,EAAK,EAAGC,EAAK,GACrB,MAAM5E,EAAImB,KAAKkC,IAAI,EAAGlC,KAAKmC,IAAIF,KAAKgB,SAAUM,IACxC3D,EAAIqC,KAAKe,MACT9B,EAAIe,KAAKiB,SAAWjB,KAAKe,MAAQnE,EACjCa,EAAIM,KAAKkC,IAAI,EAAGlC,KAAKmC,IAAIF,KAAKqB,SAAUrB,KAAKiB,SAAWrE,EAAIe,EAAIf,EAAIA,EAAI,IAE9E,MAAO,CAAEA,EAAGA,EAAI2E,EAAI/D,EADVa,EAAK2B,KAAKkB,GAAI/C,EAAKC,EAAMH,EAAK+B,KAAKmB,GAAInB,KAAKkB,KAAMzD,IACrCA,EAAGA,EAAI+D,EAAIvC,IAAGtB,KAEzC,YACI,MAAO,CACHoD,MAAOf,KAAKe,MACZC,SAAUhB,KAAKgB,SACfC,SAAUjB,KAAKiB,SACfC,GAAIlB,KAAKkB,GACTC,GAAInB,KAAKmB,KAId,MAAMM,EACT,YAAYC,EAAYC,EAAUX,GAC9BhB,KAAK0B,WAAaA,EAClB1B,KAAK2B,SAAWA,EAChB3B,KAAK4B,UAAYZ,EAErB,mBAAmB7E,GACf,OAAO,IAAIsF,EAAUtF,EAAEuF,WAAYvF,EAAEwF,SAAUxF,EAAE6E,UAErD,WACI,OAAOhB,KAAK4B,UAEhB,YACI,MAAO,CACHhF,EAAG,YACH8E,WAAY1B,KAAK0B,WACjBC,SAAU3B,KAAK2B,SACfX,SAAUhB,KAAK4B,YAI3B,SAASC,EAASlE,EAAGmE,EAAGC,GACpB,MAAM7D,EAAI,GACV,IAAI8D,EAAMF,EACV5D,EAAE+D,KAAKD,GACP,IAAK,MAAMpE,KAAKD,EACZqE,EAAMD,EAAGC,EAAKpE,GACdM,EAAE+D,KAAKD,GAEX,OAAO9D,EAgBJ,MAAMgE,EACT,YAAYC,GACRnC,KAAKmC,OAASA,EACdnC,KAAKoC,GAAKP,EAASM,EAAOE,IAAKnE,GAAMA,EAAE8C,UAAW,EAAG,CAACrD,EAAGO,IAAMP,EAAIO,GAAGM,MAAM,GAAI,GAChFwB,KAAKsC,GAAKT,EAASM,EAAOE,IAAKnE,GAAMA,EAAEmD,UAAW,EAAG,CAAC1D,EAAGO,IAAMP,EAAIO,GAAGM,MAAM,GAAI,GAEpF,mBAAmBrC,GACf,OAAO,IAAI+F,EAAS/F,EAAEgG,OAAOE,IAAI,EAAME,cAE3C,SACI,OAAOvC,KAAKmC,OAAO,GAAGjB,GAE1B,SACI,OAAOlB,KAAKmC,OAAOnC,KAAKmC,OAAOpD,OAAS,GAAGoC,GAE/C,WACI,OAAOnB,KAAKmC,OAAOE,IAAKnE,GAAMA,EAAE8C,UAAUlC,OAAO,CAACnB,EAAGO,IAAMP,EAAIO,EAAG,GAEtE,QAAQtB,GACJ,MAAM4F,EAjCd,SAAqBC,EAAOC,GACxB,IAAIC,EAAM,EACNC,EAAOH,EAAM1D,OACjB,KAAO4D,EAAMC,GAAM,CACf,MAAMC,EAAM9E,KAAK+E,OAAOH,EAAMC,GAAQ,GAClCH,EAAMI,GAAOH,EACbC,EAAME,EAAM,EAGZD,EAAOC,EAGf,OAAOF,EAqBSI,CAAY/C,KAAKoC,GAAIxF,GAC3BoG,EAAWhD,KAAKoC,GAAGI,KAAS5F,EAAI4F,EAAMA,EAAM,EAElD,OADcxC,KAAKmC,OAAOa,GACbC,QAAQrG,EAAIoD,KAAKoC,GAAGY,GAAWhD,KAAKoC,GAAGY,GAAWhD,KAAKsC,GAAGU,IAE3E,YACI,MAAO,CACHpG,EAAG,WACHuF,OAAQnC,KAAKmC,OAAOE,IAAKnE,GAAMA,EAAEgF,eAItC,MAAMC,EACT,YAAYC,GACRpD,KAAKoD,QAAUA,EAEnB,mBAAmBjH,GACf,OAAO,IAAIgH,EAAKhH,EAAEiH,QAAQf,IAAKvG,IAC3B,OAAQA,EAAEc,GACN,IAAK,WAAY,OAAOsF,EAASK,YAAYzG,GAC7C,IAAK,YAAa,OAAO2F,EAAUc,YAAYzG,OAI3D,WACI,OAAOkE,KAAKoD,QAAQf,IAAKvG,GAAMA,EAAEkF,YAAYlC,OAAO,CAACnB,EAAGO,IAAMP,EAAIO,EAAG,GAEzE,OAAOxC,GAAK,OAAOsE,KAAKoD,QAAQ1H,GAChC,eAAe2H,EAAaC,GACxB,IAAIC,EAAiB,EACrB,OAAO,IAAIJ,EAAKnD,KAAKoD,QAAQf,IAAI,CAACmB,EAAQC,IAClCD,aAAkBtB,EACXsB,EAEFA,aAAkB/B,EAInBgC,IAAMzD,KAAKoD,QAAQrE,OAAS,EACrB,IAAI0C,EAAU6B,EAAe/C,EAAOC,QAAQM,YAAY,GAAI0C,EAAOxC,YAErEyC,IAAMzD,KAAKoD,QAAQrE,OAAS,EAC1B,IAAI0C,EAAUlB,EAAOC,QAAQM,YAAY,GAAIuC,EAAaG,EAAOxC,YAEpEuC,IAAmB,GAAM,EAC3B,IAAI9B,EAAU4B,EAAaC,EAAeE,EAAOxC,YACjD,IAAIS,EAAU6B,EAAeD,EAAaG,EAAOxC,iBAZtD,IAgBb,YACI,MAAO,CACHoC,QAASpD,KAAKoD,QAAQf,IAAKvG,GAAMA,EAAEoH,eAI/C,MAAM,EACF,YAAYhC,EAAIC,GACZnB,KAAK0D,iBAAmB,EACxB1D,KAAK2D,cAAgB,EACrB3D,KAAKkB,GAAKA,EACVlB,KAAKmB,GAAKA,EACVnB,KAAKmC,OAAS,GAElB,SAAW,OAAOrE,EAAKG,EAAK+B,KAAKmB,GAAInB,KAAKkB,KAC1C,YAAc,OAAO9C,EAAMH,EAAK+B,KAAKmB,GAAInB,KAAKkB,MA6BlD,SAAS0C,EAAgBvC,EAAUwC,EAAYC,EAAU/C,EAAOG,EAAI6C,GAChE,MAAMC,GAAwB,EAAIjD,EAAQM,EAAWyC,EAAWA,EAAWD,EAAaA,IAAe,EAAI9C,GACrGkD,EAAuB5C,EAAW2C,EAClCE,EAAOnG,KAAKC,KAAK6F,EAAaA,EAAa,EAAI9C,EAAQiD,GAI7D,MAAO,CAAEG,GAAIH,EAAsBI,GAAIH,EAAsBI,IAHjDH,EAAOL,GAAc9C,EAGgCuD,IAFrDR,EAAWI,IAASnD,EAEqCmD,OAAMhD,KAAIC,GADpE9C,EAAK6C,EAAI/C,EAAKC,EAAMH,EAAK8F,EAAI7C,IAAM8C,IACqCD,MAEvF,SAASQ,EAAiBlD,EAAUwC,EAAYW,EAAQV,EAAU/C,EAAOG,EAAIuD,GACzE,MAAMJ,GAAMG,EAASX,GAAc9C,EAC7BoD,GAAMK,EAASX,GAAc,EAAIQ,EACjCK,GAAMZ,EAAWU,IAAWzD,EAC5B4D,GAAMb,EAAWU,GAAU,EAAIE,EAC/BN,EAAK/C,EAAW8C,EAAKQ,EACrBL,EAAKF,EAAKI,EACVI,EAAMxG,EAAMH,EAAKwG,EAAIvD,IAG3B,MAAO,CAAEiD,KAAIC,KAAIO,KAAIN,KAAIC,KAAII,KAAIxD,KAAIC,GAF1B9C,EAAK6C,EAAI/C,EAAKyG,EAAKT,IAEWJ,GAD9B1F,EAAK6C,EAAI/C,EAAKyG,EAAMvD,EAAWsD,IACGF,MAwBjD,SAASI,EAAyBC,EAAQC,GACtC,MAAMC,EAvBV,SAAqBF,EAAQG,GACzB,GAAgB,IAAZA,EACA,OAAOH,EAEX,MAAME,EAAgB,GACtBA,EAAc/C,KAAK6C,EAAO,IAC1B,IAAK,MAAMtH,KAAKsH,EAAOtG,MAAM,GACrBV,EAAKG,EAAKT,EAAGwH,EAAcA,EAAcjG,OAAS,KAAOkG,GACzDD,EAAc/C,KAAKzE,GAG3B,OAAOwH,EAYeE,CAAYJ,EAtStB,MAuSZ,GAA6B,IAAzBE,EAAcjG,OACd,OAAO,IAAImD,EAAS,CAAC,IAAI,EAAM,EAAG,EAAG,EAAG8C,EAAc,GAAIA,EAAc,MAE5E,MAAMG,EAAWH,EAAcxG,MAAM,GAAG6D,IAAI,CAAC1E,EAAGjC,IAAM,IAAI,EAAQsJ,EAActJ,GAAIiC,IAC9EoD,EAAQgE,EAAQK,aAChBlB,EAAOa,EAAQM,gBACfC,EAAeP,EAAQQ,gBAG7BJ,EAAS3G,MAAM,GAAGgH,QAAQ,CAACC,EAAM/J,KAC7B,MAAMgK,EAAOP,EAASzJ,GACtB+J,EAAK/B,iBAnFb,SAAwBgC,EAAMD,EAAMvB,EAAMnD,EAAOuE,GAE7C,MAAMK,GHlNWhI,EGkNI+H,EAAKE,YHlNN1H,EGkNmBuH,EAAKG,cHjNrCjI,EAAEC,EAAIM,EAAEN,EAAID,EAAEE,EAAIK,EAAEL,IADxB,IAAcF,EAAGO,EGoNpB,GAAIH,KAAK8H,IAAIF,EAAS,GAnOV,KAoOR,OAAO,EAEX,MAAMG,EAAO/H,KAAKC,MAAM,EAAI2H,GAAU,GACtC,GAAI5H,KAAK8H,IAAIC,EAAO,GAvOR,KAwOR,OAAO5B,EAEX,MAAMjF,EAAIlB,KAAKC,KAAM+C,EAAQuE,EAAeQ,GAAS,EAAIA,IAEzD,OAAO/H,KAAKmC,IAAIjB,EAAGiF,GAsES6B,CAAeL,EAAMD,EAAMvB,EAAMnD,EAAOuE,KAGpE,MAAM9F,EAAYwF,EAAcA,EAAcjG,OAAS,GACvDoG,EAASlD,KAAK,IAAI,EAAQzC,EAAWA,IACrC,IAAI9D,EAAI,EACR,KAAOA,EAAIyJ,EAASpG,OAAS,GAAG,CAC5B,MAAMiH,EAAUb,EAASzJ,GACnBuK,EAAcd,EAASzJ,EAAI,GAC3B2F,EAAW2E,EAAQjH,SACnBkC,EAAW+E,EAAQrC,cACnBuC,EAAQD,EAAYvC,iBACpBxC,EAAK8E,EAAQ9E,GACbC,EAAK6E,EAAQ7E,GACbrF,EAAI8H,EAAgBvC,EAAUJ,EAAUiF,EAAOnF,EAAOG,EAAIC,GAChE,GAAIrF,EAAEqI,IAjUE,KAsUJ6B,EAAQtC,iBAAmB3F,KAAKC,KAAKkI,EAAQA,EAAQ,EAAInF,EAAQM,GACjE3F,GAAK,OAEJ,GAAII,EAAEsI,IAAM,EAAG,CAGhB,MAAM+B,EAASpI,KAAKC,KAAKiD,EAAWA,EAAW,EAAIF,EAAQM,GACrDzE,GAAKuJ,EAASlF,GAAYF,EAChCiF,EAAQ7D,OAAS,CACb,IAAI,EAAMpB,EAAOnE,EAAGqE,EAAUC,EAAIC,IAEtC8E,EAAYtC,cAAgBwC,EAC5BzK,GAAK,OAEJ,GAAII,EAAEoI,KAAOA,EAAM,CAEpB,MAAMpC,EAAIyC,EAAiBlD,EAAUJ,EAAUiD,EAAMgC,EAAOnF,EAAOG,EAAIC,GACvE6E,EAAQ7D,OAAS,CACb,IAAI,EAAMpB,EAAOe,EAAEuC,GAAIpD,EAAUa,EAAEZ,GAAIY,EAAEX,IACzC,IAAI,EAAM,EAAGW,EAAEwC,GAAIJ,EAAMpC,EAAEX,GAAIW,EAAEiC,IACjC,IAAI,GAAOhD,EAAOe,EAAE4C,GAAIR,EAAMpC,EAAEiC,GAAIjC,EAAE2C,KAE1CwB,EAAYtC,cAAgBuC,EAC5BxK,GAAK,OAILsK,EAAQ7D,OAAS,CACb,IAAI,EAAMpB,EAAOjF,EAAEuI,GAAIpD,EAAUnF,EAAEoF,GAAIpF,EAAEqF,IACzC,IAAI,GAAOJ,EAAOjF,EAAEwI,GAAIxI,EAAEoI,KAAMpI,EAAEqF,GAAIrF,EAAEiI,KAE5CkC,EAAYtC,cAAgBuC,EAC5BxK,GAAK,EAGb,MAAMyG,EAAS,GAQf,OAPAgD,EAASK,QAAS/H,IACdA,EAAE0E,OAAOqD,QAAStH,IACVA,EAAE8C,SA5WF,MA6WAmB,EAAOF,KAAK/D,OAIjB,IAAIgE,EAASC,GC5TjB,SAASiE,EAAazH,EAAY0H,EAAWC,GAChD,OAbJ,SAAoB3H,EAAY4H,EAAWC,GACvC,MAAOtG,EAAKD,GA/BhB,SAAgBtB,GACZ,IAAI8H,GAAQC,IACRC,GAAQD,IACRE,EAAOF,IACPG,EAAOH,IACX,IAAK,MAAMpH,KAAMX,EACb,IAAK,MAAMnB,KAAK8B,EACR9B,EAAEI,EAAI6I,IACNA,EAAOjJ,EAAEI,GAETJ,EAAEK,EAAI8I,IACNA,EAAOnJ,EAAEK,GAETL,EAAEI,EAAIgJ,IACNA,EAAOpJ,EAAEI,GAETJ,EAAEK,EAAIgJ,IACNA,EAAOrJ,EAAEK,GAIrB,MAAO,CAAC,CAAED,EAAGgJ,EAAM/I,EAAGgJ,GAAQ,CAAEjJ,EAAG6I,EAAM5I,EAAG8I,IAUzBG,CAAOnI,GACpBoI,EAAeP,EAAU5I,EAAI2I,EAAU3I,EACvCoJ,EAAgBR,EAAU3I,EAAI0I,EAAU1I,EACxCoJ,EAAYF,GAAgB9G,EAAIrC,EAAIsC,EAAItC,GACxCsJ,EAAYF,GAAiB/G,EAAIpC,EAAIqC,EAAIrC,GACzCsJ,EAAQpJ,KAAKmC,IAAI+G,EAAWC,GAC5BE,EAAe/I,EAAKkI,EAAWpI,EAAKF,EAAKuI,EAAWD,GAAY,KAChEc,EAASpJ,EAAKmJ,EAAcjJ,EAAKF,EAAKgC,EAAKC,GAAc,GAARiH,IACvD,OAAOxI,EAAW0D,IAAK/C,GAAOA,EAAG+C,IAAK7E,GAAMa,EAAKF,EAAKF,EAAKT,EAAG0C,GAAMiH,GAAQE,KAIrEC,CAAW3I,EAAY,CAAEf,EAAG0I,EAAUzI,EAAGyI,GAAYrI,EAAKoI,EAAUtG,KAAM,CAAEnC,EAAG0I,EAAUzI,EAAGyI,KAMvG,SAASiB,EAAYC,EAAMC,GACvB,MAAOC,EAAOC,GAASH,GAChB7J,EAAGO,GAAKuJ,EACTG,EAAQ3J,EAAKC,EAAGP,GAChBH,EAAI,EAAEoK,EAAMhK,EAAGgK,EAAMhK,GAAIgK,EAAM/J,EAAG+J,EAAM/J,GACxCgK,EAAI,CAAClK,EAAEC,EAAI8J,EAAM9J,EAAG+J,EAAM/J,EAAID,EAAEC,EAAGD,EAAEE,EAAI6J,EAAM7J,EAAG8J,EAAM9J,EAAIF,EAAEE,GACpE,IAAIiK,GAAMpB,IACNqB,EAAKrB,IACT,IAAK,IAAIhL,EAAI,EAAGA,EAAI,EAAGA,IACnB,GAAY,GAAR8B,EAAE9B,IACF,GAAImM,EAAEnM,GAAK,EACP,OAAO,SAEV,CACD,MAAMkB,EAAIiL,EAAEnM,GAAK8B,EAAE9B,GACf8B,EAAE9B,GAAK,GAAKoM,EAAKlL,EACjBkL,EAAKlL,EACAY,EAAE9B,GAAK,GAAKqM,EAAKnL,IACtBmL,EAAKnL,GAGjB,OAAIkL,EAAKC,GAAMD,EAAK,GAAKA,EAAK,EACnB,KACJzJ,EAAKV,EAAGQ,EAAKyJ,EAAOE,IAK/B,SAASE,EAASR,EAAMS,GACpB,MAAOP,EAAOC,GAASH,EACvB,OAAOS,EAAMrK,GAAK8J,EAAM9J,GAAKqK,EAAMrK,GAAK+J,EAAM/J,GAAKqK,EAAMpK,GAAK6J,EAAM7J,GAAKoK,EAAMpK,GAAK8J,EAAM9J,EAM9F,SAASqK,EAASV,EAAMC,GACpB,MAAO9J,EAAGO,GAAKuJ,EACTU,EAAYH,EAASR,EAAM7J,GAC3ByK,EAAYJ,EAASR,EAAMtJ,GACjC,GAAIiK,GAAaC,EACb,OAAOX,EACX,GAAIU,IAAcC,EACd,MAAO,CAACX,EAAI,GAAIF,EAAYC,EAAM,CAACC,EAAI,GAAIA,EAAI,MACnD,IAAKU,GAAaC,EACd,MAAO,CAACb,EAAYC,EAAMC,GAAMA,EAAI,IACxC,MAAMY,EAAWd,EAAYC,EAAMC,GAC7Ba,EAAYf,EAAYC,EAAM,CAACC,EAAI,GAAIA,EAAI,KACjD,OAAOY,GAAYC,EAAY,CAACD,EAAUC,GAAa,KAM3D,SAASC,EAAehJ,EAAWiI,GAC/B,MAAMgB,EAAsB,GAC5B,IAAIC,EAAmB,KACvB,IAAK,IAAI/M,EAAI,EAAGA,EAAI6D,EAAUR,OAAQrD,IAAK,CACvC,MAAOiC,EAAGO,GAAK,CAACqB,EAAU7D,EAAI,GAAI6D,EAAU7D,IACtCgN,EAAYR,EAASV,EAAM,CAAC7J,EAAGO,IACjCwK,GACKD,IACDA,EAAmB,CAACC,EAAU,IAC9BF,EAAoBvG,KAAKwG,IAE7BA,EAAiBxG,KAAKyG,EAAU,IAC5BA,EAAU,KAAOxK,IAEjBuK,EAAmB,OAKvBA,EAAmB,KAG3B,OAAOD,ECjIJ,SAASG,EAAOC,EAASC,GAC5B,IAAIC,EAAQF,EAGRC,EAAYE,QACZD,EAAQ1C,EAAa0C,EAAOD,EAAYxC,UAAWwC,EAAYvC,WAG/DwC,EAAQA,EAAMzG,IAAI2G,GAAMA,EAAG3G,IAAI7E,GAAKW,EAAKX,EAV/B,KADM,MAYZqL,EAAYI,gBACZH,ED4HL,SAAuBnK,EAAY0H,EAAWC,GACjD,MAAM4C,EAAW,CAAC,CAAEtL,EAAG,EAAGC,EAAG,GAAKwI,EAAUtG,MACtCoJ,EAAS,CAAEvL,EAAG0I,EAAUzI,EAAGyI,GAC3B8C,EAAY,CAAC/K,EAAK6K,EAAS,GAAIC,GAASlL,EAAKiL,EAAS,GAAIC,IAC1DX,EAAsB,GAC5B,IAAK,MAAMjJ,KAAaZ,EACpB,IAAK,MAAM0K,KAAed,EAAehJ,EAAW6J,GAChDZ,EAAoBvG,KAAKoH,GAGjC,OAAOb,ECtISS,CAAcH,EAAOD,EAAYxC,UAAWwC,EAAYvC,YAM1C,UAA1BuC,EAAYS,UACZR,EAAQA,EAAMzJ,OAAO,CAACkK,EAAM7N,IAAMmN,EAAYW,oBAAoBC,IAAIb,EAAQlN,GAAGgO,UAElD,WAA1Bb,EAAYS,YACjBR,EAAQA,EAAMzJ,OAAO,CAACkK,EAAM7N,IAAMmN,EAAYc,qBAAqBF,IAAIb,EAAQlN,GAAGkO,UAElFf,EAAYgB,gBAAkB,IAC9Bf,EAAQA,EAAMzG,IAAK7E,GD2HpB,SAAqBsH,EAAQG,GAChC,GAAgB,IAAZA,EACA,OAAOH,EAEX,MAAME,EAAgB,CAACF,EAAO,IACxBgF,EAAW7E,EAAUA,EAC3B,IAAK,MAAMzH,KAAKsH,EAAOtG,MAAM,GACrBd,EAAMO,EAAKT,EAAGwH,EAAcA,EAAcjG,OAAS,KAAO+K,GAC1D9E,EAAc/C,KAAKzE,GAG3B,OAAOwH,ECtIsB,CAAYxH,EAAGqL,EAAYgB,mBAEpDhB,EAAYkB,YACZC,QAAQC,KAAK,iBACbnB,EJYD,SAAkBnK,GACrB,GAA0B,IAAtBA,EAAWI,OACX,OAAOJ,EAEX,SAASuL,EAAaxO,EAAG+H,GACrB,GAAI/H,IAAM+H,EACN,OAAO,EAEX,MAAM9F,EAAIgB,EAAYjD,EAAI,EAAK,GACzBwC,EAAIS,EAAY8E,EAAI,EAAK,GACzB0G,EAAKzO,EAAI,GAAM,EAAIiC,EAAEA,EAAEoB,OAAS,GAAKpB,EAAE,GACvCyM,EAAK3G,EAAI,GAAM,EAAIvF,EAAE,GAAKA,EAAEA,EAAEa,OAAS,GACvCsL,EAAKF,EAAGvM,EAAIwM,EAAGxM,EACf0M,EAAKH,EAAGtM,EAAIuM,EAAGvM,EACrB,OAAOwM,EAAKA,EAAKC,EAAKA,EAE1B,MAAMC,EAAY,IAAIjK,IACtB,IAAK,IAAI5E,EAAI,EAAGA,EAAIiD,EAAWI,OAAQrD,IACnC6O,EAAUC,IAAI9O,GAElB,MAAM+O,EAAmB,GACzB,IAAIC,EAAW,EAGf,IAFAH,EAAUI,OAAOD,GACjBD,EAAiBxI,KAAKtD,EAAW+L,IAC1BH,EAAUxK,KAAO,GAAG,CACvB,IAAI6K,EAAU,KACVC,EAAOnE,IACX,IAAK,MAAMhL,KAAK6O,EAGZ,IAAK,IAAI9G,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,MAAMzH,EAAIkO,EAAaQ,EAAc,EAAJhP,EAAQ+H,GACrCzH,EAAI6O,IACJA,EAAO7O,EACP4O,EAAc,EAAJlP,EAAQ+H,GAI9B8G,EAAUI,OAAQC,EAAU,EAAK,GACjCH,EAAiBxI,KAAK2I,EAAU,GAAM,EAChCjM,EAAYiM,EAAU,EAAK,GAC3BjM,EAAYiM,EAAU,EAAK,GAAGpM,QAAQsM,WAC5CJ,EAAWE,EAEf,OAAOH,EIxDK,CAAsB3B,GAC9BkB,QAAQe,QAAQ,kBAEhBlC,EAAYzJ,kBAAoB,IAChC4K,QAAQC,KAAK,uBACbnB,EAAQ,EAA6BA,EAAOD,EAAYzJ,mBACxD4K,QAAQe,QAAQ,wBAEhBlC,EAAYmC,eAAiB,IAC7BhB,QAAQC,KAAK,wBACbnB,EAAQ,EAAwBA,EAAOD,EAAYmC,gBACnDhB,QAAQe,QAAQ,yBAGpBjC,EAAQA,EAAMzG,IAAK2G,GAAOA,EAAG3G,IAAK7E,GAAMW,EAAKX,EAAG+C,EAAOC,QAAQC,cAE/DuJ,QAAQC,KAAK,wBACb,MAAMgB,EFgUH,SAAcnC,EAAO/D,GACxB,MAAM3B,EAAU,GAChB,IAAI8H,EAAS,CAAEtN,EAAG,EAAGC,EAAG,GAYxB,OATAiL,EAAMtD,QAAQ,CAAChI,EAAG9B,KACd,MAAMI,EAAI+I,EAAyBrH,EAAGuH,EAAQoG,gBACxCC,EAAW1P,IAAMoN,EAAM/J,OAAS,EAAIwB,EAAOC,QAAQM,YAAY,GAAKiE,EAAQqG,SAClFhI,EAAQnB,KAAK4C,EAAyB,CAACqG,EAAQpP,EAAEoF,IAAK6D,EAAQsG,cAAe,IAAI5J,EAAUsD,EAAQqG,SAAUrG,EAAQuG,WAAYvG,EAAQwG,iBAAkBzP,EAAG,IAAI2F,EAAUsD,EAAQuG,WAAYF,EAAUrG,EAAQyG,kBAClNN,EAASpP,EAAEqF,KAGfiC,EAAQnB,KAAK4C,EAAyB,CAACqG,EAAQ,CAAEtN,EAAG,EAAGC,EAAG,IAAMkH,EAAQsG,eACxEjI,EAAQnB,KAAK,IAAIR,EAAUlB,EAAOC,QAAQM,YAAY,GAAIiE,EAAQqG,SAAUrG,EAAQwG,kBAC7E,IAAIpI,EAAKC,GE9UH,CAAc0F,EAAO,CAC9BsC,SAAU7K,EAAOC,QAAQM,YAAY+H,EAAYxF,aACjDiI,WAAY/K,EAAOC,QAAQM,YAAY+H,EAAYvF,eACnD6H,eAAgB,CACZ/F,aAAcyD,EAAY4C,oBAAsBlL,EAAOC,QAAQC,WAC/D4E,gBAAiBwD,EAAY6C,mBAAqBnL,EAAOC,QAAQC,WACjE8E,gBAAiBsD,EAAY8C,uBAAyBpL,EAAOC,QAAQC,YAEzE4K,aAAc,CACVjG,aAAcyD,EAAY+C,kBAAoBrL,EAAOC,QAAQC,WAC7D4E,gBAAiBwD,EAAYgD,iBAAmBtL,EAAOC,QAAQC,WAC/D8E,gBAAiB,GAErBgG,gBAAiB1C,EAAY0C,gBAC7BC,gBAAiB3C,EAAY2C,kBAGjC,OADAxB,QAAQe,QAAQ,wBACTE,ECtEXa,KAAKC,iBAAiB,UAAYjQ,IAC9B,MAAM,MAAEgN,EAAK,YAAED,GAAgB/M,EAAEkQ,KAC3Bf,EAAOtC,EAAOG,EAAOD,GAC3BmB,QAAQC,KAAK,eACb,MAAMgC,EAAahB,EAAK/H,YACxB8G,QAAQe,QAAQ,eAChBe,KAAKI,YAAYD,KAGN","file":"55264288e88cd96aab13.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","require(\"./background-planner\");\n","export function vlen2(a) {\n    return a.x * a.x + a.y * a.y;\n}\nexport function vlen(a) {\n    return Math.sqrt(vlen2(a));\n}\nexport function vsub(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nexport function vmul(a, s) {\n    return { x: a.x * s, y: a.y * s };\n}\nexport function vnorm(a) {\n    return vmul(a, 1 / vlen(a));\n}\nexport function vadd(a, b) {\n    return { x: a.x + b.x, y: a.y + b.y };\n}\nexport function vdot(a, b) {\n    return a.x * b.x + a.y * b.y;\n}\n","import { vlen, vlen2, vsub } from \"./vec\";\nfunction dropWhile(a, f) {\n    return a.slice(a.findIndex((x) => !f(x)));\n}\n/**\n * Joins adjacent pairs of pointLists where the first ends within tolerance of where the second begins.\n *\n * e.g. with tolerance >= 0.1,\n * {{{ Seq(Seq(Vec2(0, 0), Vec2(10, 0)), Seq(Vec2(10.1, 0), Vec2(20, 0)) }}}\n * becomes\n * {{{ Seq(Seq(Vec2(0, 0), Vec2(20, 0))) }}}\n *\n * @param pointLists List of paths to join\n * @param tolerance When the endpoints of adjacent paths are closer than this, they will be joined into one path.\n * @return The optimized path list.\n */\nexport function joinNearby(pointLists, tolerance = 0.5) {\n    const tol2 = tolerance * tolerance;\n    function maybeJoin(a, b) {\n        if (vlen2(vsub(a[a.length - 1], b[0])) <= tol2) {\n            return [a.concat(dropWhile(b, (v) => vlen2(vsub(a[a.length - 1], v)) <= tol2))];\n        }\n        else {\n            return [a, b];\n        }\n    }\n    function appendAndJoin(a, b) {\n        return a.length === 0\n            ? [b]\n            : a.slice(0, -1).concat(maybeJoin(a[a.length - 1], b));\n    }\n    return pointLists.reduce(appendAndJoin, []);\n}\nfunction pathLength(pointList) {\n    if (pointList.length <= 1) {\n        return 0;\n    }\n    let length = 0;\n    let lastPoint = pointList[0];\n    for (let i = 1; i < pointList.length; i++) {\n        length += vlen(vsub(lastPoint, pointList[i]));\n        lastPoint = pointList[i];\n    }\n    return length;\n}\nexport function elideShortPaths(pointLists, minimumPathLength) {\n    return pointLists.filter((pl) => pathLength(pl) >= minimumPathLength);\n}\n/** Reorder paths greedily, attempting to minimize the amount of pen-up travel time. */\nexport function optimize(pointLists) {\n    if (pointLists.length === 0) {\n        return pointLists;\n    }\n    function dist2Between(i, j) {\n        if (i === j) {\n            return 0;\n        }\n        const a = pointLists[(i / 2) | 0];\n        const b = pointLists[(j / 2) | 0];\n        const pa = i % 2 === 0 ? a[a.length - 1] : a[0];\n        const pb = j % 2 === 0 ? b[0] : b[b.length - 1];\n        const dx = pa.x - pb.x;\n        const dy = pa.y - pb.y;\n        return dx * dx + dy * dy;\n    }\n    const unvisited = new Set();\n    for (let i = 0; i < pointLists.length; i++) {\n        unvisited.add(i);\n    }\n    const sortedPointLists = [];\n    let firstIdx = 0;\n    unvisited.delete(firstIdx);\n    sortedPointLists.push(pointLists[firstIdx]);\n    while (unvisited.size > 0) {\n        let nextIdx = null;\n        let minD = Infinity;\n        for (const i of unvisited) {\n            // if j == 0, the path is traversed \"forwards\" (i.e. in the direction listed in the input)\n            // if j == 1, the path is traversed \"reversed\" (i.e. the opposite direction to the input)\n            for (let j = 0; j < 2; j++) {\n                const d = dist2Between(firstIdx, i * 2 + j);\n                if (d < minD) {\n                    minD = d;\n                    nextIdx = i * 2 + j;\n                }\n            }\n        }\n        unvisited.delete((nextIdx / 2) | 0);\n        sortedPointLists.push(nextIdx % 2 === 0\n            ? pointLists[(nextIdx / 2) | 0]\n            : pointLists[(nextIdx / 2) | 0].slice().reverse());\n        firstIdx = nextIdx;\n    }\n    return sortedPointLists;\n}\n","import { vmul } from \"./vec\";\nfunction vround(v, digits = 2) {\n    return { x: Number(v.x.toFixed(digits)), y: Number(v.y.toFixed(digits)) };\n}\nexport class PaperSize {\n    constructor(size) {\n        this.size = size;\n    }\n    get landscape() {\n        return new PaperSize({\n            x: Math.max(this.size.x, this.size.y),\n            y: Math.min(this.size.x, this.size.y),\n        });\n    }\n    get portrait() {\n        return new PaperSize({\n            x: Math.min(this.size.x, this.size.y),\n            y: Math.max(this.size.x, this.size.y),\n        });\n    }\n    get isLandscape() {\n        return this.size.x === Math.max(this.size.x, this.size.y);\n    }\n}\nPaperSize.standard = {\n    \"USLetter\": new PaperSize(vround(vmul({ x: 8.5, y: 11 }, 25.4))),\n    \"USLegal\": new PaperSize(vround(vmul({ x: 8.5, y: 14 }, 25.4))),\n    \"ArchA\": new PaperSize(vround(vmul({ x: 9, y: 12 }, 25.4))),\n    \"A3\": new PaperSize({ x: 297, y: 420 }),\n    \"A4\": new PaperSize({ x: 210, y: 297 }),\n    \"A5\": new PaperSize({ x: 148, y: 210 }),\n    \"A6\": new PaperSize({ x: 105, y: 148 }),\n    \"6x8\": new PaperSize(vround(vmul({ x: 6, y: 8 }, 25.4))),\n    \"5x7\": new PaperSize(vround(vmul({ x: 5, y: 7 }, 25.4))),\n    \"11x14\": new PaperSize(vround(vmul({ x: 11, y: 14 }, 25.4))),\n};\n","/**\n * Cribbed from https://github.com/fogleman/axi/blob/master/axi/planner.py\n */\nconst epsilon = 1e-9;\nimport { PaperSize } from \"./paper-size\";\nimport { vadd, vdot, vlen, vmul, vnorm, vsub } from \"./vec\";\nexport const defaultPlanOptions = {\n    penUpHeight: 50,\n    penDownHeight: 60,\n    pointJoinRadius: 0,\n    pathJoinRadius: 0.5,\n    paperSize: PaperSize.standard.ArchA.landscape,\n    marginMm: 20,\n    selectedGroupLayers: new Set(),\n    selectedStrokeLayers: new Set(),\n    layerMode: 'stroke',\n    penDownAcceleration: 200,\n    penDownMaxVelocity: 50,\n    penDownCorneringFactor: 0.127,\n    penUpAcceleration: 400,\n    penUpMaxVelocity: 200,\n    penDropDuration: 0.12,\n    penLiftDuration: 0.12,\n    sortPaths: true,\n    fitPage: true,\n    cropToMargins: true,\n    minimumPathLength: 0,\n};\nexport const Device = {\n    Axidraw: {\n        stepsPerMm: 5,\n        // Practical min/max that you might ever want the pen servo to go on the AxiDraw (v2)\n        // Units: 83ns resolution pwm output.\n        // Defaults: penup at 12000 (1ms), pendown at 16000 (1.33ms).\n        penServoMin: 7500,\n        penServoMax: 28000,\n        penPctToPos(pct) {\n            const t = pct / 100.0;\n            return Math.round(this.penServoMin * t + this.penServoMax * (1 - t));\n        }\n    }\n};\nexport const AxidrawFast = {\n    penDownProfile: {\n        acceleration: 200 * Device.Axidraw.stepsPerMm,\n        maximumVelocity: 50 * Device.Axidraw.stepsPerMm,\n        corneringFactor: 0.127 * Device.Axidraw.stepsPerMm\n    },\n    penUpProfile: {\n        acceleration: 400 * Device.Axidraw.stepsPerMm,\n        maximumVelocity: 200 * Device.Axidraw.stepsPerMm,\n        corneringFactor: 0\n    },\n    penUpPos: Device.Axidraw.penPctToPos(50),\n    penDownPos: Device.Axidraw.penPctToPos(60),\n    penDropDuration: 0.12,\n    penLiftDuration: 0.12,\n};\nexport class Block {\n    constructor(accel, duration, vInitial, p1, p2) {\n        if (!(vInitial >= 0)) {\n            throw new Error(`vInitial must be >= 0, but was ${vInitial}`);\n        }\n        if (!(vInitial + accel * duration >= -epsilon)) {\n            throw new Error(`vFinal must be >= 0, but vInitial=${vInitial}, duration=${duration}, accel=${accel}`);\n        }\n        this.accel = accel;\n        this.duration = duration;\n        this.vInitial = vInitial;\n        this.p1 = p1;\n        this.p2 = p2;\n        this.distance = vlen(vsub(p1, p2));\n    }\n    static deserialize(o) {\n        return new Block(o.accel, o.duration, o.vInitial, o.p1, o.p2);\n    }\n    get vFinal() { return Math.max(0, this.vInitial + this.accel * this.duration); }\n    instant(tU, dt = 0, ds = 0) {\n        const t = Math.max(0, Math.min(this.duration, tU));\n        const a = this.accel;\n        const v = this.vInitial + this.accel * t;\n        const s = Math.max(0, Math.min(this.distance, this.vInitial * t + a * t * t / 2));\n        const p = vadd(this.p1, vmul(vnorm(vsub(this.p2, this.p1)), s));\n        return { t: t + dt, p, s: s + ds, v, a };\n    }\n    serialize() {\n        return {\n            accel: this.accel,\n            duration: this.duration,\n            vInitial: this.vInitial,\n            p1: this.p1,\n            p2: this.p2,\n        };\n    }\n}\nexport class PenMotion {\n    constructor(initialPos, finalPos, duration) {\n        this.initialPos = initialPos;\n        this.finalPos = finalPos;\n        this.pDuration = duration;\n    }\n    static deserialize(o) {\n        return new PenMotion(o.initialPos, o.finalPos, o.duration);\n    }\n    duration() {\n        return this.pDuration;\n    }\n    serialize() {\n        return {\n            t: \"PenMotion\",\n            initialPos: this.initialPos,\n            finalPos: this.finalPos,\n            duration: this.pDuration,\n        };\n    }\n}\nfunction scanLeft(a, z, op) {\n    const b = [];\n    let acc = z;\n    b.push(acc);\n    for (const x of a) {\n        acc = op(acc, x);\n        b.push(acc);\n    }\n    return b;\n}\nfunction sortedIndex(array, obj) {\n    let low = 0;\n    let high = array.length;\n    while (low < high) {\n        const mid = Math.floor((low + high) / 2);\n        if (array[mid] < obj) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nexport class XYMotion {\n    constructor(blocks) {\n        this.blocks = blocks;\n        this.ts = scanLeft(blocks.map((b) => b.duration), 0, (a, b) => a + b).slice(0, -1);\n        this.ss = scanLeft(blocks.map((b) => b.distance), 0, (a, b) => a + b).slice(0, -1);\n    }\n    static deserialize(o) {\n        return new XYMotion(o.blocks.map(Block.deserialize));\n    }\n    get p1() {\n        return this.blocks[0].p1;\n    }\n    get p2() {\n        return this.blocks[this.blocks.length - 1].p2;\n    }\n    duration() {\n        return this.blocks.map((b) => b.duration).reduce((a, b) => a + b, 0);\n    }\n    instant(t) {\n        const idx = sortedIndex(this.ts, t);\n        const blockIdx = this.ts[idx] === t ? idx : idx - 1;\n        const block = this.blocks[blockIdx];\n        return block.instant(t - this.ts[blockIdx], this.ts[blockIdx], this.ss[blockIdx]);\n    }\n    serialize() {\n        return {\n            t: \"XYMotion\",\n            blocks: this.blocks.map((b) => b.serialize())\n        };\n    }\n}\nexport class Plan {\n    constructor(motions) {\n        this.motions = motions;\n    }\n    static deserialize(o) {\n        return new Plan(o.motions.map((m) => {\n            switch (m.t) {\n                case \"XYMotion\": return XYMotion.deserialize(m);\n                case \"PenMotion\": return PenMotion.deserialize(m);\n            }\n        }));\n    }\n    duration() {\n        return this.motions.map((m) => m.duration()).reduce((a, b) => a + b, 0);\n    }\n    motion(i) { return this.motions[i]; }\n    withPenHeights(penUpHeight, penDownHeight) {\n        let penMotionIndex = 0;\n        return new Plan(this.motions.map((motion, j) => {\n            if (motion instanceof XYMotion) {\n                return motion;\n            }\n            else if (motion instanceof PenMotion) {\n                // Uuuugh this is really hacky. We should instead store the\n                // pen-up/pen-down heights in a single place and reference them from\n                // the PenMotions. Then we can change them in just one place.\n                if (j === this.motions.length - 3) {\n                    return new PenMotion(penDownHeight, Device.Axidraw.penPctToPos(0), motion.duration());\n                }\n                else if (j === this.motions.length - 1) {\n                    return new PenMotion(Device.Axidraw.penPctToPos(0), penUpHeight, motion.duration());\n                }\n                return (penMotionIndex++ % 2 === 0\n                    ? new PenMotion(penUpHeight, penDownHeight, motion.duration())\n                    : new PenMotion(penDownHeight, penUpHeight, motion.duration()));\n            }\n        }));\n    }\n    serialize() {\n        return {\n            motions: this.motions.map((m) => m.serialize())\n        };\n    }\n}\nclass Segment {\n    constructor(p1, p2) {\n        this.maxEntryVelocity = 0;\n        this.entryVelocity = 0;\n        this.p1 = p1;\n        this.p2 = p2;\n        this.blocks = [];\n    }\n    length() { return vlen(vsub(this.p2, this.p1)); }\n    direction() { return vnorm(vsub(this.p2, this.p1)); }\n}\nfunction cornerVelocity(seg1, seg2, vMax, accel, cornerFactor) {\n    // https://onehossshay.wordpress.com/2011/09/24/improving_grbl_cornering_algorithm/\n    const cosine = -vdot(seg1.direction(), seg2.direction());\n    // assert(!cosine.isNaN, s\"cosine was NaN: $seg1, $seg2, ${seg1.direction}, ${seg2.direction}\")\n    if (Math.abs(cosine - 1) < epsilon) {\n        return 0;\n    }\n    const sine = Math.sqrt((1 - cosine) / 2);\n    if (Math.abs(sine - 1) < epsilon) {\n        return vMax;\n    }\n    const v = Math.sqrt((accel * cornerFactor * sine) / (1 - sine));\n    // assert(!v.isNaN, s\"v was NaN: $accel, $cornerFactor, $sine\")\n    return Math.min(v, vMax);\n}\n/** Compute a triangular velocity profile with piecewise constant acceleration.\n *\n * The maximum velocity is derived from the acceleration and the distance to be travelled.\n *\n * @param distance Distance to travel (equal to |p3-p1|).\n * @param initialVel Starting velocity, unit length per unit time.\n * @param finalVel Final velocity, unit length per unit time.\n * @param accel Magnitude of acceleration, unit length per unit time per unit time.\n * @param p1 Starting point.\n * @param p3 Ending point.\n * @return\n */\nfunction computeTriangle(distance, initialVel, finalVel, accel, p1, p3) {\n    const acceleratingDistance = (2 * accel * distance + finalVel * finalVel - initialVel * initialVel) / (4 * accel);\n    const deceleratingDistance = distance - acceleratingDistance;\n    const vMax = Math.sqrt(initialVel * initialVel + 2 * accel * acceleratingDistance);\n    const t1 = (vMax - initialVel) / accel;\n    const t2 = (finalVel - vMax) / -accel;\n    const p2 = vadd(p1, vmul(vnorm(vsub(p3, p1)), acceleratingDistance));\n    return { s1: acceleratingDistance, s2: deceleratingDistance, t1, t2, vMax, p1, p2, p3 };\n}\nfunction computeTrapezoid(distance, initialVel, maxVel, finalVel, accel, p1, p4) {\n    const t1 = (maxVel - initialVel) / accel;\n    const s1 = (maxVel + initialVel) / 2 * t1;\n    const t3 = (finalVel - maxVel) / -accel;\n    const s3 = (finalVel + maxVel) / 2 * t3;\n    const s2 = distance - s1 - s3;\n    const t2 = s2 / maxVel;\n    const dir = vnorm(vsub(p4, p1));\n    const p2 = vadd(p1, vmul(dir, s1));\n    const p3 = vadd(p1, vmul(dir, (distance - s3)));\n    return { s1, s2, s3, t1, t2, t3, p1, p2, p3, p4 };\n}\nfunction dedupPoints(points, epsilon) {\n    if (epsilon === 0) {\n        return points;\n    }\n    const dedupedPoints = [];\n    dedupedPoints.push(points[0]);\n    for (const p of points.slice(1)) {\n        if (vlen(vsub(p, dedupedPoints[dedupedPoints.length - 1])) > epsilon) {\n            dedupedPoints.push(p);\n        }\n    }\n    return dedupedPoints;\n}\n/**\n * Plan a path, using a constant acceleration profile.\n * This function plans only a single x/y motion of the tool,\n * i.e. between a single pen-down/pen-up pair.\n *\n * @param points Sequence of points to pass through\n * @param profile Tooling profile to use\n * @return A plan of action\n */\nfunction constantAccelerationPlan(points, profile) {\n    const dedupedPoints = dedupPoints(points, epsilon);\n    if (dedupedPoints.length === 1) {\n        return new XYMotion([new Block(0, 0, 0, dedupedPoints[0], dedupedPoints[0])]);\n    }\n    const segments = dedupedPoints.slice(1).map((a, i) => new Segment(dedupedPoints[i], a));\n    const accel = profile.acceleration;\n    const vMax = profile.maximumVelocity;\n    const cornerFactor = profile.corneringFactor;\n    // Calculate the maximum entry velocity for each segment based on the angle between it\n    // and the previous segment.\n    segments.slice(1).forEach((seg2, i) => {\n        const seg1 = segments[i];\n        seg2.maxEntryVelocity = cornerVelocity(seg1, seg2, vMax, accel, cornerFactor);\n    });\n    // This is to force the velocity to zero at the end of the path.\n    const lastPoint = dedupedPoints[dedupedPoints.length - 1];\n    segments.push(new Segment(lastPoint, lastPoint));\n    let i = 0;\n    while (i < segments.length - 1) {\n        const segment = segments[i];\n        const nextSegment = segments[i + 1];\n        const distance = segment.length();\n        const vInitial = segment.entryVelocity;\n        const vExit = nextSegment.maxEntryVelocity;\n        const p1 = segment.p1;\n        const p2 = segment.p2;\n        const m = computeTriangle(distance, vInitial, vExit, accel, p1, p2);\n        if (m.s1 < -epsilon) {\n            // We'd have to start decelerating _before we started on this segment_. backtrack.\n            // In order enter this segment slow enough to be leaving it at vExit, we need to\n            // compute a maximum entry velocity s.t. we can slow down in the distance we have.\n            // TODO: verify this equation.\n            segment.maxEntryVelocity = Math.sqrt(vExit * vExit + 2 * accel * distance);\n            i -= 1;\n        }\n        else if (m.s2 <= 0) {\n            // No deceleration.\n            // TODO: shouldn't we check vMax here and maybe do trapezoid? should the next case below come first?\n            const vFinal = Math.sqrt(vInitial * vInitial + 2 * accel * distance);\n            const t = (vFinal - vInitial) / accel;\n            segment.blocks = [\n                new Block(accel, t, vInitial, p1, p2)\n            ];\n            nextSegment.entryVelocity = vFinal;\n            i += 1;\n        }\n        else if (m.vMax > vMax) {\n            // Triangle profile would exceed maximum velocity, so top out at vMax.\n            const z = computeTrapezoid(distance, vInitial, vMax, vExit, accel, p1, p2);\n            segment.blocks = [\n                new Block(accel, z.t1, vInitial, z.p1, z.p2),\n                new Block(0, z.t2, vMax, z.p2, z.p3),\n                new Block(-accel, z.t3, vMax, z.p3, z.p4)\n            ];\n            nextSegment.entryVelocity = vExit;\n            i += 1;\n        }\n        else {\n            // Accelerate, then decelerate.\n            segment.blocks = [\n                new Block(accel, m.t1, vInitial, m.p1, m.p2),\n                new Block(-accel, m.t2, m.vMax, m.p2, m.p3)\n            ];\n            nextSegment.entryVelocity = vExit;\n            i += 1;\n        }\n    }\n    const blocks = [];\n    segments.forEach((s) => {\n        s.blocks.forEach((b) => {\n            if (b.duration > epsilon) {\n                blocks.push(b);\n            }\n        });\n    });\n    return new XYMotion(blocks);\n}\nexport function plan(paths, profile) {\n    const motions = [];\n    let curPos = { x: 0, y: 0 };\n    // for each path: move to the initial point, put the pen down, draw the path,\n    // then pick the pen up.\n    paths.forEach((p, i) => {\n        const m = constantAccelerationPlan(p, profile.penDownProfile);\n        const penUpPos = i === paths.length - 1 ? Device.Axidraw.penPctToPos(0) : profile.penUpPos;\n        motions.push(constantAccelerationPlan([curPos, m.p1], profile.penUpProfile), new PenMotion(profile.penUpPos, profile.penDownPos, profile.penDropDuration), m, new PenMotion(profile.penDownPos, penUpPos, profile.penLiftDuration));\n        curPos = m.p2;\n    });\n    // finally, move back to (0, 0).\n    motions.push(constantAccelerationPlan([curPos, { x: 0, y: 0 }], profile.penUpProfile));\n    motions.push(new PenMotion(Device.Axidraw.penPctToPos(0), profile.penUpPos, profile.penDropDuration));\n    return new Plan(motions);\n}\n","import { vadd, vlen2, vmul, vsub } from \"./vec\";\n/** Format a smallish duration in 2h30m15s form */\nexport function formatDuration(seconds) {\n    const hours = Math.floor(seconds / 60 / 60);\n    const mins = Math.floor((seconds - hours * 60 * 60) / 60);\n    const secs = Math.floor(seconds - hours * 60 * 60 - mins * 60);\n    const parts = [\n        [hours, \"h\"],\n        [mins, \"m\"],\n        [secs, \"s\"]\n    ];\n    return parts.slice(parts.findIndex((x) => x[0] !== 0)).map(([v, u]) => `${v}${u}`).join(\"\");\n}\n/** Return the top-left and bottom-right corners of the bounding box containing all points in pointLists */\nfunction extent(pointLists) {\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let minX = Infinity;\n    let minY = Infinity;\n    for (const pl of pointLists) {\n        for (const p of pl) {\n            if (p.x > maxX) {\n                maxX = p.x;\n            }\n            if (p.y > maxY) {\n                maxY = p.y;\n            }\n            if (p.x < minX) {\n                minX = p.x;\n            }\n            if (p.y < minY) {\n                minY = p.y;\n            }\n        }\n    }\n    return [{ x: minX, y: minY }, { x: maxX, y: maxY }];\n}\n/**\n * Scale pointLists to fit within the bounding box specified by (targetMin, targetMax).\n *\n * Preserves aspect ratio, scaling as little as possible to completely fit within the box.\n *\n * Also centers the paths within the box.\n */\nfunction scaleToFit(pointLists, targetMin, targetMax) {\n    const [min, max] = extent(pointLists);\n    const availWidthMm = targetMax.x - targetMin.x;\n    const availHeightMm = targetMax.y - targetMin.y;\n    const scaleFitX = availWidthMm / (max.x - min.x);\n    const scaleFitY = availHeightMm / (max.y - min.y);\n    const scale = Math.min(scaleFitX, scaleFitY);\n    const targetCenter = vadd(targetMin, vmul(vsub(targetMax, targetMin), 0.5));\n    const offset = vsub(targetCenter, vmul(vsub(max, min), scale * 0.5));\n    return pointLists.map((pl) => pl.map((p) => vadd(vmul(vsub(p, min), scale), offset)));\n}\n/** Scale a drawing to fill a piece of paper, with the given size and margins. */\nexport function scaleToPaper(pointLists, paperSize, marginMm) {\n    return scaleToFit(pointLists, { x: marginMm, y: marginMm }, vsub(paperSize.size, { x: marginMm, y: marginMm }));\n}\n/**\n * Liang-Barsky algorithm for computing segment-AABB intersection.\n * https://gist.github.com/ChickenProp/3194723\n */\nfunction liangBarsky(aabb, seg) {\n    const [lower, upper] = aabb;\n    const [a, b] = seg;\n    const delta = vsub(b, a);\n    const p = [-delta.x, delta.x, -delta.y, delta.y];\n    const q = [a.x - lower.x, upper.x - a.x, a.y - lower.y, upper.y - a.y];\n    var u1 = -Infinity;\n    var u2 = Infinity;\n    for (let i = 0; i < 4; i++) {\n        if (p[i] == 0) {\n            if (q[i] < 0)\n                return null;\n        }\n        else {\n            const t = q[i] / p[i];\n            if (p[i] < 0 && u1 < t)\n                u1 = t;\n            else if (p[i] > 0 && u2 > t)\n                u2 = t;\n        }\n    }\n    if (u1 > u2 || u1 > 1 || u1 < 0)\n        return null;\n    return vadd(a, vmul(delta, u1));\n}\n/**\n * Returns true if aabb contains point (edge-inclusive).\n */\nfunction contains(aabb, point) {\n    const [lower, upper] = aabb;\n    return point.x >= lower.x && point.x <= upper.x && point.y >= lower.y && point.y <= upper.y;\n}\n/**\n * Returns a segment that is the subset of seg which is completely contained\n * within aabb, or null if seg is outside aabb.\n */\nfunction truncate(aabb, seg) {\n    const [a, b] = seg;\n    const containsA = contains(aabb, a);\n    const containsB = contains(aabb, b);\n    if (containsA && containsB)\n        return seg;\n    if (containsA && !containsB)\n        return [seg[0], liangBarsky(aabb, [seg[1], seg[0]])];\n    if (!containsA && containsB)\n        return [liangBarsky(aabb, seg), seg[1]];\n    const forwards = liangBarsky(aabb, seg);\n    const backwards = liangBarsky(aabb, [seg[1], seg[0]]);\n    return forwards && backwards ? [forwards, backwards] : null;\n}\n/**\n * Given a polyline, returns a list of polylines that form a subset of the\n * input polyline that is completely within aabb.\n */\nfunction cropLineToAabb(pointList, aabb) {\n    const truncatedPointLists = [];\n    let currentPointList = null;\n    for (let i = 1; i < pointList.length; i++) {\n        const [a, b] = [pointList[i - 1], pointList[i]];\n        const truncated = truncate(aabb, [a, b]);\n        if (truncated) {\n            if (!currentPointList) {\n                currentPointList = [truncated[0]];\n                truncatedPointLists.push(currentPointList);\n            }\n            currentPointList.push(truncated[1]);\n            if (truncated[1] !== b) {\n                // the end was truncated, record the end point and end the line\n                currentPointList = null;\n            }\n        }\n        else {\n            // the segment was entirely outside the aabb, end the line if there was one.\n            currentPointList = null;\n        }\n    }\n    return truncatedPointLists;\n}\n/**\n * Crops a drawing so it is kept entirely within the given margin.\n */\nexport function cropToMargins(pointLists, paperSize, marginMm) {\n    const pageAabb = [{ x: 0, y: 0 }, paperSize.size];\n    const margin = { x: marginMm, y: marginMm };\n    const insetAabb = [vadd(pageAabb[0], margin), vsub(pageAabb[1], margin)];\n    const truncatedPointLists = [];\n    for (const pointList of pointLists) {\n        for (const croppedLine of cropLineToAabb(pointList, insetAabb)) {\n            truncatedPointLists.push(croppedLine);\n        }\n    }\n    return truncatedPointLists;\n}\nexport function dedupPoints(points, epsilon) {\n    if (epsilon === 0) {\n        return points;\n    }\n    const dedupedPoints = [points[0]];\n    const epsilon2 = epsilon * epsilon;\n    for (const p of points.slice(1)) {\n        if (vlen2(vsub(p, dedupedPoints[dedupedPoints.length - 1])) > epsilon2) {\n            dedupedPoints.push(p);\n        }\n    }\n    return dedupedPoints;\n}\n","import * as Optimization from \"./optimization\";\nimport * as Planning from \"./planning\";\nimport { Device } from \"./planning\";\nimport { dedupPoints, scaleToPaper, cropToMargins } from \"./util\";\nimport { vmul } from \"./vec\";\n// CSS, and thus SVG, defines 1px = 1/96th of 1in\n// https://www.w3.org/TR/css-values-4/#absolute-lengths\nconst svgUnitsPerInch = 96;\nconst mmPerInch = 25.4;\nconst mmPerSvgUnit = mmPerInch / svgUnitsPerInch;\nexport function replan(inPaths, planOptions) {\n    let paths = inPaths;\n    // Compute scaling using _all_ the paths, so it's the same no matter what\n    // layers are selected.\n    if (planOptions.fitPage) {\n        paths = scaleToPaper(paths, planOptions.paperSize, planOptions.marginMm);\n    }\n    else {\n        paths = paths.map(ps => ps.map(p => vmul(p, mmPerSvgUnit)));\n        if (planOptions.cropToMargins) {\n            paths = cropToMargins(paths, planOptions.paperSize, planOptions.marginMm);\n        }\n    }\n    // Rescaling loses the stroke info, so refer back to the original paths to\n    // filter based on the stroke. Rescaling doesn't change the number or order\n    // of the paths.\n    if (planOptions.layerMode === 'group') {\n        paths = paths.filter((path, i) => planOptions.selectedGroupLayers.has(inPaths[i].groupId));\n    }\n    else if (planOptions.layerMode === 'stroke') {\n        paths = paths.filter((path, i) => planOptions.selectedStrokeLayers.has(inPaths[i].stroke));\n    }\n    if (planOptions.pointJoinRadius > 0) {\n        paths = paths.map((p) => dedupPoints(p, planOptions.pointJoinRadius));\n    }\n    if (planOptions.sortPaths) {\n        console.time(\"sorting paths\");\n        paths = Optimization.optimize(paths);\n        console.timeEnd(\"sorting paths\");\n    }\n    if (planOptions.minimumPathLength > 0) {\n        console.time(\"eliding short paths\");\n        paths = Optimization.elideShortPaths(paths, planOptions.minimumPathLength);\n        console.timeEnd(\"eliding short paths\");\n    }\n    if (planOptions.pathJoinRadius > 0) {\n        console.time(\"joining nearby paths\");\n        paths = Optimization.joinNearby(paths, planOptions.pathJoinRadius);\n        console.timeEnd(\"joining nearby paths\");\n    }\n    // Convert the paths to units of \"steps\".\n    paths = paths.map((ps) => ps.map((p) => vmul(p, Device.Axidraw.stepsPerMm)));\n    // And finally, motion planning.\n    console.time(\"planning pen motions\");\n    const plan = Planning.plan(paths, {\n        penUpPos: Device.Axidraw.penPctToPos(planOptions.penUpHeight),\n        penDownPos: Device.Axidraw.penPctToPos(planOptions.penDownHeight),\n        penDownProfile: {\n            acceleration: planOptions.penDownAcceleration * Device.Axidraw.stepsPerMm,\n            maximumVelocity: planOptions.penDownMaxVelocity * Device.Axidraw.stepsPerMm,\n            corneringFactor: planOptions.penDownCorneringFactor * Device.Axidraw.stepsPerMm,\n        },\n        penUpProfile: {\n            acceleration: planOptions.penUpAcceleration * Device.Axidraw.stepsPerMm,\n            maximumVelocity: planOptions.penUpMaxVelocity * Device.Axidraw.stepsPerMm,\n            corneringFactor: 0,\n        },\n        penDropDuration: planOptions.penDropDuration,\n        penLiftDuration: planOptions.penLiftDuration,\n    });\n    console.timeEnd(\"planning pen motions\");\n    return plan;\n}\n","import { replan } from './massager';\nself.addEventListener(\"message\", (m) => {\n    const { paths, planOptions } = m.data;\n    const plan = replan(paths, planOptions);\n    console.time(\"serializing\");\n    const serialized = plan.serialize();\n    console.timeEnd(\"serializing\");\n    self.postMessage(serialized);\n});\n// eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion\nexport default {};\n"],"sourceRoot":""}